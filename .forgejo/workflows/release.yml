name: Release

on:
  push:
    branches: [main]

jobs:
  release:
    name: Create Release
    runs-on: [docker, light]
    container:
      image: catthehacker/ubuntu:act-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Detect version from commits
        id: version
        run: |
          # Get last tag
          LAST_TAG=$(git tag -l "v*" --sort=-v:refname | head -n1 || echo "")

          if [ -z "$LAST_TAG" ]; then
            # No previous tag - initial release
            NEW_VERSION="1.0.0"
            echo "No previous tag found, starting with v1.0.0"
            echo "Initial release" > /tmp/commits.txt
          else
            CURRENT_VERSION="${LAST_TAG#v}"
            echo "Current version: $CURRENT_VERSION"

            # Get commits since last tag
            COMMITS=$(git log --pretty=format:"%s" "$LAST_TAG"..HEAD 2>/dev/null || echo "")

            if [ -z "$COMMITS" ]; then
              echo "No commits since last tag"
              echo "skip=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            # Save commits for changelog
            git log --pretty=format:"- %s" "$LAST_TAG"..HEAD > /tmp/commits.txt

            # Analyze commits for version bump
            # feat! / BREAKING CHANGE → major
            # feat → minor
            # fix, refactor, perf → patch
            # docs, style, test, chore, ci → no release
            MAJOR=0
            MINOR=0
            PATCH=0

            while IFS= read -r commit; do
              if [[ "$commit" =~ ^feat.*!: ]] || [[ "$commit" =~ BREAKING.CHANGE ]]; then
                MAJOR=1
                echo "  MAJOR: $commit"
              elif [[ "$commit" =~ ^feat ]]; then
                MINOR=1
                echo "  MINOR: $commit"
              elif [[ "$commit" =~ ^fix ]] || [[ "$commit" =~ ^refactor ]] || [[ "$commit" =~ ^perf ]]; then
                PATCH=1
                echo "  PATCH: $commit"
              else
                echo "  SKIP: $commit"
              fi
            done <<< "$COMMITS"

            # Calculate new version
            IFS='.' read -r v_major v_minor v_patch <<< "$CURRENT_VERSION"
            v_major=${v_major:-0}
            v_minor=${v_minor:-0}
            v_patch=${v_patch:-0}

            if [ $MAJOR -eq 1 ]; then
              v_major=$((v_major + 1))
              v_minor=0
              v_patch=0
              NEW_VERSION="${v_major}.${v_minor}.${v_patch}"
            elif [ $MINOR -eq 1 ]; then
              v_minor=$((v_minor + 1))
              v_patch=0
              NEW_VERSION="${v_major}.${v_minor}.${v_patch}"
            elif [ $PATCH -eq 1 ]; then
              v_patch=$((v_patch + 1))
              NEW_VERSION="${v_major}.${v_minor}.${v_patch}"
            else
              echo "No releasable commits (only docs/style/test/chore/ci)"
              echo "skip=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          SHORT_SHA=$(git rev-parse --short HEAD)

          echo "New version: $NEW_VERSION"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "tag=v${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Check if release exists
        id: check
        if: steps.version.outputs.skip != 'true'
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog with Devstral
        id: changelog
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        env:
          MISTRAL_API_KEY: ${{ secrets.MISTRAL_API_KEY }}
        run: |
          COMMITS=$(cat /tmp/commits.txt)
          VERSION="${{ steps.version.outputs.version }}"

          # Call Devstral via native Mistral API
          RESPONSE=$(curl -s -X POST "https://api.mistral.ai/v1/chat/completions" \
            -H "Authorization: Bearer $MISTRAL_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg commits "$COMMITS" \
              --arg version "$VERSION" \
              '{
                model: "devstral-small-latest",
                messages: [
                  {
                    role: "system",
                    content: "You are a release note writer. Generate a concise changelog in markdown. Group changes by type (### Features, ### Bug Fixes, ### Improvements). Be brief. IMPORTANT: Output raw markdown only - do NOT wrap your response in code blocks. Do NOT include version headers or dates - start directly with ### section headers."
                  },
                  {
                    role: "user",
                    content: ("Summarize these commits into a changelog (no version/date header, just grouped changes):\n\n" + $commits)
                  }
                ],
                max_tokens: 1000
              }')")

          # Extract the changelog content
          CHANGELOG=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')

          if [ -z "$CHANGELOG" ]; then
            echo "Devstral failed, using commit list as fallback"
            CHANGELOG="$COMMITS"
          fi

          # Strip any code block wrappers (```markdown ... ```)
          CHANGELOG=$(echo "$CHANGELOG" | sed '/^```/d')

          # Save changelog
          echo "$CHANGELOG" > /tmp/changelog.md
          echo "Changelog generated:"
          cat /tmp/changelog.md

      - name: Update version in package.json
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Update package.json
          jq --arg v "$VERSION" '.version = $v' package.json > package.json.tmp
          mv package.json.tmp package.json

          echo "Updated package.json to version $VERSION"

      - name: Update version in plugin.json
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Update plugin/.claude-plugin/plugin.json
          jq --arg v "$VERSION" '.version = $v' plugin/.claude-plugin/plugin.json > plugin.json.tmp
          mv plugin.json.tmp plugin/.claude-plugin/plugin.json

          echo "Updated plugin.json to version $VERSION"

      - name: Update CHANGELOG.md
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DATE=$(date +%Y-%m-%d)

          # Create new changelog entry file
          echo "## [${VERSION}] - ${DATE}" > /tmp/new_entry.md
          echo "" >> /tmp/new_entry.md
          cat /tmp/changelog.md >> /tmp/new_entry.md
          echo "" >> /tmp/new_entry.md

          # Prepend to CHANGELOG.md (or create if doesn't exist)
          if [ -f CHANGELOG.md ]; then
            if head -1 CHANGELOG.md | grep -q "^# "; then
              head -1 CHANGELOG.md > /tmp/changelog_new.md
              echo "" >> /tmp/changelog_new.md
              cat /tmp/new_entry.md >> /tmp/changelog_new.md
              tail -n +2 CHANGELOG.md >> /tmp/changelog_new.md
            else
              cat /tmp/new_entry.md > /tmp/changelog_new.md
              cat CHANGELOG.md >> /tmp/changelog_new.md
            fi
            mv /tmp/changelog_new.md CHANGELOG.md
          else
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            cat /tmp/new_entry.md >> CHANGELOG.md
          fi

          echo "Updated CHANGELOG.md"

      - name: Update version in README.md
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Update version badge in README.md
          sed -i "s/version-[0-9]*\.[0-9]*\.[0-9]*/version-${VERSION}/" README.md

          echo "Updated README.md version badge"

      - name: Commit version updates
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          git config user.name "Release Bot"
          git config user.email "release@customable.de"

          git add package.json plugin/.claude-plugin/plugin.json CHANGELOG.md README.md
          git commit -m "chore(release): bump version to ${VERSION}" || echo "No changes to commit"
          git push origin main

      - name: Create Git Tag
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          git config user.name "Release Bot"
          git config user.email "release@customable.de"
          git tag -a "${{ steps.version.outputs.tag }}" -m "Release ${{ steps.version.outputs.version }}"
          git push origin "${{ steps.version.outputs.tag }}"

      - name: Create Release
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          CHANGELOG=$(cat /tmp/changelog.md)
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          BACKTICKS='```'

          # Build release body
          {
            echo "## Installation"
            echo ""
            echo "$BACKTICKS"
            echo "> /plugin marketplace add https://github.com/maxritter/claude-mem.git"
            echo "> /plugin install claude-mem"
            echo "$BACKTICKS"
            echo ""
            echo "## Changes"
            echo ""
            echo "$CHANGELOG"
            echo ""
            echo "---"
            echo "Built from commit ${{ steps.version.outputs.sha }}"
          } > /tmp/release_body.md

          BODY=$(cat /tmp/release_body.md)

          # Create release via API
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: token ${{ secrets.RELEASE_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg tag "$TAG" \
              --arg name "Release $TAG" \
              --arg body "$BODY" \
              '{tag_name: $tag, name: $name, body: $body}')" \
            "https://git.customable.host/api/v1/repos/${{ github.repository }}/releases")

          echo "Release $TAG created!"
          echo "$RESPONSE" | jq .

      # Marketplace version is updated in this repo's .claude-plugin/marketplace.json
      # No separate marketplace repo needed - this repo IS the marketplace
