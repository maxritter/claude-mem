name: Release

on:
  push:
    branches: [main]

jobs:
  release:
    name: Create Release
    runs-on: [docker, light]
    container:
      image: catthehacker/ubuntu:act-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Detect version from commits
        id: version
        run: |
          # Get last tag
          LAST_TAG=$(git tag -l "v*" --sort=-v:refname | head -n1 || echo "")

          if [ -z "$LAST_TAG" ]; then
            # No previous tag - initial release
            NEW_VERSION="1.0.0"
            echo "No previous tag found, starting with v1.0.0"
            echo "Initial release" > /tmp/commits.txt
          else
            CURRENT_VERSION="${LAST_TAG#v}"
            echo "Current version: $CURRENT_VERSION"

            # Get commits since last tag
            COMMITS=$(git log --pretty=format:"%s" "$LAST_TAG"..HEAD 2>/dev/null || echo "")

            if [ -z "$COMMITS" ]; then
              echo "No commits since last tag"
              echo "skip=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            # Save commits for changelog
            git log --pretty=format:"- %s" "$LAST_TAG"..HEAD > /tmp/commits.txt

            # Analyze commits for version bump
            # feat! / BREAKING CHANGE → major
            # feat → minor
            # fix, refactor, perf → patch
            # docs, style, test, chore, ci → no release
            MAJOR=0
            MINOR=0
            PATCH=0

            while IFS= read -r commit; do
              if [[ "$commit" =~ ^feat.*!: ]] || [[ "$commit" =~ BREAKING.CHANGE ]]; then
                MAJOR=1
                echo "  MAJOR: $commit"
              elif [[ "$commit" =~ ^feat ]]; then
                MINOR=1
                echo "  MINOR: $commit"
              elif [[ "$commit" =~ ^fix ]] || [[ "$commit" =~ ^refactor ]] || [[ "$commit" =~ ^perf ]]; then
                PATCH=1
                echo "  PATCH: $commit"
              else
                echo "  SKIP: $commit"
              fi
            done <<< "$COMMITS"

            # Calculate new version
            IFS='.' read -r v_major v_minor v_patch <<< "$CURRENT_VERSION"
            v_major=${v_major:-0}
            v_minor=${v_minor:-0}
            v_patch=${v_patch:-0}

            if [ $MAJOR -eq 1 ]; then
              v_major=$((v_major + 1))
              v_minor=0
              v_patch=0
              NEW_VERSION="${v_major}.${v_minor}.${v_patch}"
            elif [ $MINOR -eq 1 ]; then
              v_minor=$((v_minor + 1))
              v_patch=0
              NEW_VERSION="${v_major}.${v_minor}.${v_patch}"
            elif [ $PATCH -eq 1 ]; then
              v_patch=$((v_patch + 1))
              NEW_VERSION="${v_major}.${v_minor}.${v_patch}"
            else
              echo "No releasable commits (only docs/style/test/chore/ci)"
              echo "skip=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          SHORT_SHA=$(git rev-parse --short HEAD)

          echo "New version: $NEW_VERSION"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "tag=v${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Check if release exists
        id: check
        if: steps.version.outputs.skip != 'true'
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog with Devstral
        id: changelog
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        env:
          MISTRAL_API_KEY: ${{ secrets.MISTRAL_API_KEY }}
        run: |
          COMMITS=$(cat /tmp/commits.txt)
          VERSION="${{ steps.version.outputs.version }}"

          # Call Devstral via native Mistral API
          RESPONSE=$(curl -s -X POST "https://api.mistral.ai/v1/chat/completions" \
            -H "Authorization: Bearer $MISTRAL_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg commits "$COMMITS" \
              --arg version "$VERSION" \
              '{
                model: "devstral-small-latest",
                messages: [
                  {
                    role: "system",
                    content: "You are a release note writer. Generate a concise, well-formatted changelog in markdown. Group changes by type (Features, Bug Fixes, Improvements, etc.). Be brief but informative. Do not include a header - start directly with the grouped changes."
                  },
                  {
                    role: "user",
                    content: ("Generate a changelog for version " + $version + " based on these commits:\n\n" + $commits)
                  }
                ],
                max_tokens: 1000
              }')")

          # Extract the changelog content
          CHANGELOG=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')

          if [ -z "$CHANGELOG" ]; then
            echo "Devstral failed, using commit list as fallback"
            CHANGELOG="$COMMITS"
          fi

          # Save changelog
          echo "$CHANGELOG" > /tmp/changelog.md
          echo "Changelog generated:"
          cat /tmp/changelog.md

      - name: Update version in package.json
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Update package.json
          jq --arg v "$VERSION" '.version = $v' package.json > package.json.tmp
          mv package.json.tmp package.json

          echo "Updated package.json to version $VERSION"

      - name: Update version in plugin.json
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Update plugin/.claude-plugin/plugin.json
          jq --arg v "$VERSION" '.version = $v' plugin/.claude-plugin/plugin.json > plugin.json.tmp
          mv plugin.json.tmp plugin/.claude-plugin/plugin.json

          echo "Updated plugin.json to version $VERSION"

      - name: Commit version updates
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          git config user.name "Release Bot"
          git config user.email "release@customable.de"

          git add package.json plugin/.claude-plugin/plugin.json
          git commit -m "chore(release): bump version to ${VERSION}" || echo "No changes to commit"
          git push origin main

      - name: Create Git Tag
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          git config user.name "Release Bot"
          git config user.email "release@customable.de"
          git tag -a "${{ steps.version.outputs.tag }}" -m "Release ${{ steps.version.outputs.version }}"
          git push origin "${{ steps.version.outputs.tag }}"

      - name: Create Release
        if: steps.version.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          CHANGELOG=$(cat /tmp/changelog.md)
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"

          BODY=$(cat << 'BODYEOF'
          ## Installation

          ```
          > /plugin marketplace add https://git.customable.host/customable/claude-plugins.git
          > /plugin install claude-mem
          ```

          ## Changes

          BODYEOF
          )

          BODY="${BODY}
          ${CHANGELOG}

          ---
          Built from commit ${{ steps.version.outputs.sha }}"

          # Create release via API
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: token ${{ secrets.RELEASE_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg tag "$TAG" \
              --arg name "Release $TAG" \
              --arg body "$BODY" \
              '{tag_name: $tag, name: $name, body: $body}')" \
            "https://git.customable.host/api/v1/repos/${{ github.repository }}/releases")

          echo "Release $TAG created!"
          echo "$RESPONSE" | jq .
